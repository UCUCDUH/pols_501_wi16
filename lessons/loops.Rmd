---
title: "For loops"
author: "Jeffrey Arnold"
date: "February 4, 2016"
output: html_document
---

## For Loops

Suppose we want to print each word in a sentence.
One way is to use six `print` statements:

```{r}
best_practice <- c("Let", "the", "computer", "do", "the", "work")
print(sentence[1])
print(sentence[2])
print(sentence[3])
print(sentence[4])
print(sentence[5])
print(sentence[6])
```

but that's a bad approach for two reasons:

 1. It doesn't scale: if we want to print the elements in a vector that's hundreds long, we'd be better off just typing them in.

 2. It's fragile: if we give it a longer vector, it only prints part of the data, and if we give it a shorter input, it returns `NA` values because we're asking for elements that don't exist!

```{r}
sentence[-6]
```

Here's a better approach:

```{r}
for (word in sentence) {
  print(word)
}
```

This is shorter---certainly shorter than something that prints every character in a hundred-letter string---and more robust as well.
If you change what is in sentence, it will still work.
```{r}
sentence <- sentence[1:3]
for (word in sentence) {
  print(word)
}
```

The improved version of the code uses a *for loop* to repeat an operation---in this case, printing---once for each thing in a collection.
The general form of a loop is:

```{r, eval=FALSE}
for (variable in collection) {
  do things with variable
}
```

We can name the [loop variable](reference.html#loop-variable) anything we like (with a few [restrictions][], e.g. the name of the variable cannot start with a digit).
`in` is part of the `for` syntax.
Note that the body of the loop is enclosed in curly braces `{ }`.
For a single-line loop body, as here, the braces aren't needed, but it is good practice to include them as we did.

[restrictions]: http://cran.r-project.org/doc/manuals/R-intro.html#R-commands_003b-case-sensitivity-etc

Here's another loop that repeatedly updates a variable:

```{r}
len <- 0
vowels <- c("a", "e", "i", "o", "u")
for (v in vowels) {
  len <- len + 1
}
# Number of vowels
len
```

It's worth tracing the execution of this little program step by step.
Since there are five elements in the vector `vowels`, the statement inside the loop will be executed five times.
The first time around, `len` is zero (the value assigned to it on line 1) and `v` is `"a"`.
The statement adds 1 to the old value of `len`, producing 1, and updates `len` to refer to that new value.
The next time around, `v` is `"e"` and `len` is 1, so `len` is updated to be 2.
After three more updates, `len` is 5; since there is nothing left in the vector `vowels` for R to process, the loop finishes.

Note that a loop variable is just a variable that's being used to record progress in a loop.
It still exists after the loop is over, and we can re-use variables previously defined as loop variables as well:

```{r}
letter <- "z"
for (letter in c("a", "b", "c")) {
  print(letter)
}
# after the loop, letter is
letter
```

Note also that finding the length of a vector is such a common operation that R actually has a built-in function to do it called `length`:

```{r}
length(vowels)
```

`length` is much faster than any R function we could write ourselves, and much easier to read than a two-line loop; it will also give us the length of many other things that we haven't met yet, so we should always use it when we can (see this [lesson](01-supp-data-structures.html) to learn more about the different ways to store data in R).

We can name the [loop variable](reference.html#loop-variable) anything we like (with a few [restrictions][], e.g. the name of the variable cannot start with a digit).
`in` is part of the `for` syntax.
Note that the body of the loop is enclosed in curly braces `{ }`.
For a single-line loop body, as here, the braces aren't needed, but it is good practice to include them as we did.

[restrictions]: http://cran.r-project.org/doc/manuals/R-intro.html#R-commands_003b-case-sensitivity-etc

Here's another loop that repeatedly updates a variable:

```{r}
len <- 0
vowels <- c("a", "e", "i", "o", "u")
for (v in vowels) {
  len <- len + 1
}
# Number of vowels
len
```

It's worth tracing the execution of this little program step by step.
Since there are five elements in the vector `vowels`, the statement inside the loop will be executed five times.
The first time around, `len` is zero (the value assigned to it on line 1) and `v` is `"a"`.
The statement adds 1 to the old value of `len`, producing 1, and updates `len` to refer to that new value.
The next time around, `v` is `"e"` and `len` is 1, so `len` is updated to be 2.
After three more updates, `len` is 5; since there is nothing left in the vector `vowels` for R to process, the loop finishes.

Note that a loop variable is just a variable that's being used to record progress in a loop.
It still exists after the loop is over, and we can re-use variables previously defined as loop variables as well:

```{r}
letter <- "z"
for (letter in c("a", "b", "c")) {
  print(letter)
}
# after the loop, letter is
letter
```

Note also that finding the length of a vector is such a common operation that R actually has a built-in function to do it called `length`:

```{r}
length(vowels)
```

`length` is much faster than any R function we could write ourselves, and much easier to read than a two-line loop; it will also give us the length of many other things that we haven't met yet, so we should always use it when we can.


`r start_challenge()`
R has a built-in function called `seq` that creates a list of numbers:

```{r}
seq(3)
```

Using `seq` use a for loop to print the first **N** natural numbers, one per line:
`r end_challenge()`
`r start_solution()`
```{r, echo=-1}
N <- 3
nseq <- seq(N)
for (num in nseq) {
  print(num)
}
```
`r end_solution()`

Building a data frame from a list of data frames.

```{r}
means <- c(-5, 0, 4)
n <- 5
results <- list()
for (i in means) {
  results[[i]] <-
    data_frame(x = rnorm(n, mean = means[i]),
               mu = means[i])
}
```
The object `results` is a list of data frames,
```{r}
results
```
We can stack these data frames into a single data frame using the **dplyr** function `bind_rows`,
```{r}
bind_rows(results)
```



* * * 

This is derived from the  Software Carpentry lesson, [Programming in R](http://swcarpentry.github.io/r-novice-inflammation/), [CC-BY](http://software-carpentry.org/license/).
